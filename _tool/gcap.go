package main

import (
	"archive/tar"
	"bufio"
	"bytes"
	"compress/gzip"
	"errors"
	"fmt"
	"io"
	"io/ioutil"
	"log"
	"net/http"
	"os"
	"os/exec"
	"path"
	"strings"
	"unicode"
)

const (
	ncursesUrl = "https://invisible-island.net/datafiles/release/ncurses.tar.gz"
	cacheDir   = ".cache/"
	capFile    = "ncurses-6.1/include/Caps"
)

var (
	bufBool   = new(bytes.Buffer)
	bufNum    = new(bytes.Buffer)
	bufStr    = new(bytes.Buffer)
	countBool = 0
	countNum  = 0
	countStr  = 0
)

func main() {
	pn, err := prepare()
	if err != nil {
		log.Fatal(err)
	}

	bs, err := readCapFile(pn)
	if err != nil {
		log.Fatal(err)
	}

	err = generate(bs)
	if err != nil {
		log.Fatal(err)
	}

	fmt.Println("Done!")
}

func prepare() (string, error) {
	err := os.MkdirAll(cacheDir, 0755)
	if err != nil {
		return "", err
	}

	pn := path.Join(cacheDir, path.Base(ncursesUrl))

	fi, err := os.Stat(pn)
	if err == nil && !fi.IsDir() {
		return pn, nil
	}

	fmt.Println("Download:", ncursesUrl)
	resp, err := http.Get(ncursesUrl)
	if err != nil {
		return "", err
	}
	defer resp.Body.Close()

	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return "", err
	}

	fmt.Println("Save:", pn)
	err = ioutil.WriteFile(pn, body, 0644)
	if err != nil {
		return "", err
	}

	return pn, nil
}

func readCapFile(pn string) ([]byte, error) {
	bs, err := ioutil.ReadFile(pn)
	if err != nil {
		return nil, err
	}

	gr, err := gzip.NewReader(bytes.NewReader(bs))
	if err != nil {
		return nil, err
	}
	defer gr.Close()

	tr := tar.NewReader(gr)
	for {
		h, err := tr.Next()
		if err == io.EOF {
			break // End of archive
		}
		if err != nil {
			return nil, err
		}

		if h.Name == capFile {
			b := bytes.NewBuffer(make([]byte, 0, h.Size))
			n, err := io.Copy(b, tr)
			if err != nil {
				return nil, err
			}
			if n != h.Size || n != int64(b.Len()) {
				return nil, errors.New("read capFile error")
			}
			return b.Bytes(), nil
		}
	}
	return nil, fmt.Errorf("could not read capFile: %s", capFile)
}

func generate(b []byte) error {
	r := bytes.NewReader(b)
	s := bufio.NewScanner(r)

	for s.Scan() {
		b := s.Bytes()
		b = bytes.TrimSpace(b)

		if len(b) == 0 || b[0] == '#' {
			continue
		}

		l := string(b)

		if strings.HasPrefix(l, "capalias") {
			continue
		}

		if strings.HasPrefix(l, "infoalias") {
			continue
		}

		err := parseLine(l)
		if err != nil {
			return err
		}
	}

	err := s.Err()
	if err != nil {
		return err
	}

	err = writeFile()
	if err != nil {
		return err
	}

	return nil
}

func parseLine(line string) error {
	f, err := parseFields(line)
	if err != nil {
		return err
	}

	var b *bytes.Buffer
	var c *int

	switch f[2] {
	case "bool":
		b = bufBool
		c = &countBool
	case "num":
		b = bufNum
		c = &countNum
	case "str":
		b = bufStr
		c = &countStr
	default:
		return errors.New("illegal format")
	}

	s := fmt.Sprintf("%s = %d // %-8s - %s\n", toCamelCase(f[0]), *c, f[1], f[7])
	b.WriteString(s)

	*c++
	return nil
}

func parseFields(line string) ([]string, error) {
	ss := make([]string, 8)

	wasSpace := true
	li := 0
	idx := 0

	for i, r := range line {
		if unicode.IsSpace(r) {
			if !wasSpace {
				wasSpace = true
				ss[idx] = line[li:i]
				idx++
			}
		} else {
			if wasSpace {
				wasSpace = false
				li = i
				if idx == 7 {
					break
				}
			}
		}
	}

	if !wasSpace {
		ss[idx] = line[li:]
	}

	if idx != 7 {
		return nil, errors.New("illegal format")
	}

	for _, s := range ss {
		if s == "" {
			return nil, errors.New("field is empty")
		}
	}

	return ss, nil
}

func toCamelCase(s string) string {
	rs := make([]rune, len(s))
	i := 0
	b := true

	for _, r := range s {
		if r == '_' {
			if b {
				panic("illegal format")
			}
			b = true
		} else {
			if b {
				b = false
				r = unicode.ToUpper(r)
			}
			rs[i] = r
			i++
		}
	}

	if b {
		panic("illegal format")
	}

	return string(rs[:i])
}

func writeFile() error {
	s := fmt.Sprintf(fileFormat, countBool, countNum, countStr,
		bufBool.Bytes(), bufNum.Bytes(), bufStr.Bytes())

	err := ioutil.WriteFile(fileName, []byte(s), 0644)
	if err != nil {
		return err
	}

	err = exec.Command("gofmt", "-s", "-w", fileName).Run()
	if err != nil {
		return err
	}

	return nil
}

const (
	fileName   = "capability.go"
	fileFormat = `
package terminfo

// Code generated by _tool/gcap.go. DO NOT EDIT.

// Count of cababilities
const (
  BoolCapCount = %d
  NumCapCount  = %d
  StrCapCount  = %d
)

// Boolean capabilities
const ( %s )

// Numeric capabilities
const ( %s )

// String capabilities
const ( %s )
`
)
